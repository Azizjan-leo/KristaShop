#nullable enable
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using KristaShop.Common.Implementation.DataAccess;
using KristaShop.Common.Interfaces.DataAccess;
using KristaShop.Common.Models.Session;
using KristaShop.DataAccess.Entities;
using Microsoft.EntityFrameworkCore;

namespace KristaShop.DataAccess.Domain {
    public abstract class ChangeLogDbContext : BaseDbContext {
        protected ChangeLogDbContext(DbContextOptions<KristaShopDbContext> options) : base(options) { }

        public override async Task<int> SaveChangesAsync(bool acceptAllChangesOnSuccess, UserSession? session,
            CancellationToken cancellationToken = default) {
            return await _saveChanges(acceptAllChangesOnSuccess, session, cancellationToken);
        }

        public override async Task<int> SaveChangesAsync(bool acceptAllChangesOnSuccess,
            CancellationToken cancellationToken = default) {
            return await _saveChanges(acceptAllChangesOnSuccess, null, cancellationToken);
        }

        private async Task<int> _saveChanges(bool acceptAllChangesOnSuccess, UserSession? session,
            CancellationToken cancellationToken) {
            var changedEntries = _beforeSaveChanges(session);
            var result = await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
            await _afterSaveChanges(changedEntries);
            return result;
        }

        private List<DataChangeLogEntry> _beforeSaveChanges(UserSession? session) {
            ChangeTracker.DetectChanges();
            var changedEntries = new List<DataChangeLogEntry>();
            foreach (var entry in ChangeTracker.Entries()) {
                if (entry.Entity is DataChangeLog or not IEntityChangeLoggable || entry.State is EntityState.Detached or EntityState.Unchanged)
                    continue;

                var changedEntry = new DataChangeLogEntry(entry, entry.Metadata.GetTableName(), session?.UserId);
                changedEntries.Add(changedEntry);

                foreach (var property in entry.Properties) {
                    if (property.IsTemporary) {
                        // value will be generated by the database, get the value after saving
                        changedEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    string propertyName = property.Metadata.Name;
                    if (property.Metadata.IsPrimaryKey()) {
                        changedEntry.KeyValues[propertyName] = property.CurrentValue;
                        continue;
                    }

                    switch (entry.State) {
                        case EntityState.Added:
                            changedEntry.NewValues[propertyName] = property.CurrentValue;
                            break;

                        case EntityState.Deleted:
                            changedEntry.OldValues[propertyName] = property.OriginalValue;
                            break;

                        case EntityState.Modified:
                            if (property.IsModified) {
                                changedEntry.OldValues[propertyName] = property.OriginalValue;
                                changedEntry.NewValues[propertyName] = property.CurrentValue;
                            }

                            break;
                    }
                }
            }

            // Save audit entities that have all the modifications
            foreach (var changedEntry in changedEntries.Where(_ => !_.HasTemporaryProperties)) {
                var item = changedEntry.ToLogEntity();
                Set<DataChangeLog>().Add(item);
            }

            // keep a list of entries where the value of some properties are unknown at this step
            return changedEntries.Where(_ => _.HasTemporaryProperties).ToList();
        }

        private Task _afterSaveChanges(IReadOnlyCollection<DataChangeLogEntry> changedEntries) {
            if (!changedEntries.Any())
                return Task.CompletedTask;

            foreach (var changedEntry in changedEntries) {
                // Get the final value of the temporary properties
                foreach (var prop in changedEntry.TemporaryProperties) {
                    if (prop.Metadata.IsPrimaryKey()) {
                        changedEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                    } else {
                        changedEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                }

                // Save the Audit entry
                Set<DataChangeLog>().Add(changedEntry.ToLogEntity());
            }

            return SaveChangesAsync();
        }
    }
}